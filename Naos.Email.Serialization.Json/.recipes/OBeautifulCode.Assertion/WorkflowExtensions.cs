// --------------------------------------------------------------------------------------------------------------------
// <copyright file="WorkflowExtensions.cs" company="OBeautifulCode">
//   Copyright (c) OBeautifulCode 2018. All rights reserved.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in OBeautifulCode.Assertion.Recipes source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace OBeautifulCode.Assertion.Recipes
{
    using global::System.Collections;
    using global::System.Globalization;
    using global::System.Linq;
    using global::System.Runtime.CompilerServices;
    using OBeautifulCode.Type.Recipes;

    /// <summary>
    /// Workflow related extension methods, excluding verification.
    /// </summary>
#if !OBeautifulCodeAssertionSolution
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [global::System.CodeDom.Compiler.GeneratedCode("OBeautifulCode.Assertion.Recipes", "See package version number")]
    internal
#else
    public
#endif
    static class WorkflowExtensions
    {
        /// <summary>
        /// Initializes an argument-related subject for verification.
        /// </summary>
        /// <typeparam name="TSubject">The type of subject.</typeparam>
        /// <param name="value">The value of the subject.</param>
        /// <param name="name">Optional name of the subject.  Default is null; the subject is unnamed.</param>
        /// <param name="forRecording">Optional value indicating whether the verification(s) are recorded (verification exceptions are stored in tracker, not thrown).  Default is not to record (throw exceptions on verification failures).</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        [MethodImpl(MethodImplOptions.NoInlining)]
        public static AssertionTracker MustForArg<TSubject>(
            [ValidatedNotNull] this TSubject value,
            string name = null,
            bool forRecording = false)
        {
            var result = forRecording
                ? value.AsArg(name).ForRecording().Must()
                : value.AsArg(name).Must();

            return result;
        }

        /// <summary>
        /// Initializes an operation-related subject for verification.
        /// </summary>
        /// <typeparam name="TSubject">The type of subject.</typeparam>
        /// <param name="value">The value of the subject.</param>
        /// <param name="name">Optional name of the subject.  Default is null; the subject is unnamed.</param>
        /// <param name="forRecording">Optional value indicating whether the verification(s) are recorded (verification exceptions are stored in tracker, not thrown).  Default is not to record (throw exceptions on verification failures).</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        [MethodImpl(MethodImplOptions.NoInlining)]
        public static AssertionTracker MustForOp<TSubject>(
            [ValidatedNotNull] this TSubject value,
            string name = null,
            bool forRecording = false)
        {
            var result = forRecording
                ? value.AsOp(name).ForRecording().Must()
                : value.AsOp(name).Must();

            return result;
        }

        /// <summary>
        /// Initializes an test-related subject for verification.
        /// </summary>
        /// <typeparam name="TSubject">The type of subject.</typeparam>
        /// <param name="value">The value of the subject.</param>
        /// <param name="name">Optional name of the subject.  Default is null; the subject is unnamed.</param>
        /// <param name="forRecording">Optional value indicating whether the verification(s) are recorded (verification exceptions are stored in tracker, not thrown).  Default is not to record (throw exceptions on verification failures).</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        [MethodImpl(MethodImplOptions.NoInlining)]
        public static AssertionTracker MustForTest<TSubject>(
            [ValidatedNotNull] this TSubject value,
            string name = null,
            bool forRecording = false)
        {
            var result = forRecording
                ? value.AsTest(name).ForRecording().Must()
                : value.AsTest(name).Must();

            return result;
        }

        /// <summary>
        /// Initializes a subject for verification(s) that are recorded (verification exceptions are stored in tracker, not thrown).
        /// </summary>
        /// <typeparam name="TSubject">The type of subject.</typeparam>
        /// <param name="value">The value of the subject.</param>
        /// <param name="name">Optional name of the subject.  Default is null; the subject is unnamed.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        [MethodImpl(MethodImplOptions.NoInlining)]
        public static AssertionTracker MustForRecording<TSubject>(
            [ValidatedNotNull] this TSubject value,
            string name = null)
        {
            var result = value.As(name, AssertionKind.Unknown).ForRecording().Must();

            return result;
        }

        /// <summary>
        /// Initializes an argument-related subject for verification.
        /// </summary>
        /// <typeparam name="TSubject">The type of subject.</typeparam>
        /// <param name="value">The value of the subject.</param>
        /// <param name="name">Optional name of the subject.  Default is null; the subject is unnamed.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        [MethodImpl(MethodImplOptions.NoInlining)]
        public static AssertionTracker AsArg<TSubject>(
            [ValidatedNotNull] this TSubject value,
            string name = null)
        {
            var result = value.As(name, AssertionKind.Argument);

            return result;
        }

        /// <summary>
        /// Initializes an operation-related subject for verification.
        /// </summary>
        /// <typeparam name="TSubject">The type of subject.</typeparam>
        /// <param name="value">The value of the subject.</param>
        /// <param name="name">Optional name of the subject.  Default is null; the subject is unnamed.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        [MethodImpl(MethodImplOptions.NoInlining)]
        public static AssertionTracker AsOp<TSubject>(
            [ValidatedNotNull] this TSubject value,
            string name = null)
        {
            var result = value.As(name, AssertionKind.Operation);

            return result;
        }

        /// <summary>
        /// Initializes an test-related subject for verification.
        /// </summary>
        /// <typeparam name="TSubject">The type of subject.</typeparam>
        /// <param name="value">The value of the subject.</param>
        /// <param name="name">Optional name of the subject.  Default is null; the subject is unnamed.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        [MethodImpl(MethodImplOptions.NoInlining)]
        public static AssertionTracker AsTest<TSubject>(
            [ValidatedNotNull] this TSubject value,
            string name = null)
        {
            var result = value.As(name, AssertionKind.Test);

            return result;
        }

        /// <summary>
        /// Initializes a subject for verification(s) that are recorded
        /// (verification exceptions are stored in tracker, not thrown).
        /// </summary>
        /// <typeparam name="TSubject">The type of subject.</typeparam>
        /// <param name="value">The value of the subject.</param>
        /// <param name="name">
        /// Optional name of the subject if the subject hasn't been initialized with an As... call.
        /// Default is null; the subject is unnamed.
        /// </param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        [MethodImpl(MethodImplOptions.NoInlining)]
        public static AssertionTracker ForRecording<TSubject>(
            [ValidatedNotNull] this TSubject value,
            string name = null)
        {
            AssertionTracker result;
            if (value is AssertionTracker assertionTracker)
            {
                if (!string.IsNullOrWhiteSpace(name))
                {
                    Verifications.ThrowImproperUseOfFramework(Verifications.SubjectInitializedAndCannotBeNamedErrorMessage);
                }

                assertionTracker.ThrowImproperUseOfFrameworkIfDetected(
                    AssertionTrackerShould.Exist,
                    AssertionTrackerShould.NotBeRecording,
                    AssertionTrackerShould.NotBeMusted,
                    AssertionTrackerShould.NotBeEached, 
                    AssertionTrackerShould.NotBeVerified,
                    AssertionTrackerShould.NotHaveEachedValueVerifiedForIteration);

                result = assertionTracker;
            }
            else
            {
                result = value.As(name, AssertionKind.Unknown);
            }

            result.Actions |= Actions.PutIntoRecordingMode;

            return result;
        }

        /// <summary>
        /// Initializes a subject for verification.
        /// </summary>
        /// <typeparam name="TSubject">The type of the subject.</typeparam>
        /// <param name="value">The value of the subject.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        [MethodImpl(MethodImplOptions.NoInlining)]
        public static AssertionTracker Must<TSubject>(
            [ValidatedNotNull] this TSubject value)
        {
            AssertionTracker result;
            if (value is AssertionTracker tracker)
            {
                // As... has already been called
                result = tracker;

                result.ThrowImproperUseOfFrameworkIfDetected(
                    AssertionTrackerShould.Exist, 
                    AssertionTrackerShould.NotBeMusted, 
                    AssertionTrackerShould.NotBeEached,
                    AssertionTrackerShould.NotBeVerified, 
                    AssertionTrackerShould.NotHaveEachedValueVerifiedForIteration);
            }
            else
            {
                // As... has not yet been called
                result = BuildTrackerFromAnonymousObject(value) ?? new AssertionTracker
                {
                    SubjectValue = value,
                    SubjectType = typeof(TSubject),
                };
            }

            result.Actions |= Actions.Musted;

            return result;
        }

        /// <summary>
        /// Specifies that the verifications should be applied
        /// to the elements of the <see cref="IEnumerable"/> subject.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <returns>
        /// The assertion tracker in a state where verifications will be
        /// applied to the elements of the <see cref="IEnumerable"/> subject.
        /// </returns>
        public static AssertionTracker Each(
            [ValidatedNotNull] this AssertionTracker assertionTracker)
        {
            assertionTracker.ThrowImproperUseOfFrameworkIfDetected(
                AssertionTrackerShould.Exist, 
                AssertionTrackerShould.BeMusted, 
                AssertionTrackerShould.NotBeEached);

            assertionTracker.Actions |= Actions.Eached;

            return assertionTracker;
        }

        /// <summary>
        /// Specifies another verification.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <returns>
        /// The assertion tracker.
        /// </returns>
        public static AssertionTracker And(
            [ValidatedNotNull] this AssertionTracker assertionTracker)
        {
            assertionTracker.ThrowImproperUseOfFrameworkIfDetected(
                AssertionTrackerShould.Exist, 
                AssertionTrackerShould.BeMusted,
                AssertionTrackerShould.BeVerifiedAtLeastOnce);

            return assertionTracker;
        }

        /// <summary>
        /// Throws an exception if an improper use of the framework is detected.
        /// </summary>
        /// <param name="assertionTracker">The assertion tracker.</param>
        /// <param name="assertionTrackerShoulds">Specifies what should or should not be true about the assertion tracker.</param>
        internal static void ThrowImproperUseOfFrameworkIfDetected(
            [ValidatedNotNull] this AssertionTracker assertionTracker,
            params AssertionTrackerShould[] assertionTrackerShoulds)
        {
            var shouldThrow = false;

            if (assertionTracker == null)
            {
                shouldThrow = true;
            }
            else
            {
                foreach (var assertionTrackerShould in assertionTrackerShoulds)
                {
                    switch (assertionTrackerShould)
                    {
                        case AssertionTrackerShould.Exist:
                            shouldThrow = assertionTracker.SubjectType == null;
                            break;
                        case AssertionTrackerShould.NotExist:
                            shouldThrow = true;
                            break;
                        case AssertionTrackerShould.BeCategorized:
                            shouldThrow = (!assertionTracker.Actions.HasFlag(Actions.Categorized)) || (assertionTracker.AssertionKind == AssertionKind.Unknown);
                            break;
                        case AssertionTrackerShould.NotBeCategorized:
                            shouldThrow = assertionTracker.Actions.HasFlag(Actions.Categorized) || (assertionTracker.AssertionKind != AssertionKind.Unknown);
                            break;
                        case AssertionTrackerShould.BeNamed:
                            shouldThrow = (!assertionTracker.Actions.HasFlag(Actions.Named)) || (assertionTracker.SubjectName == null);
                            break;
                        case AssertionTrackerShould.NotBeNamed:
                            shouldThrow = assertionTracker.Actions.HasFlag(Actions.Named) || (assertionTracker.SubjectName != null);
                            break;
                        case AssertionTrackerShould.BeRecording:
                            shouldThrow = !assertionTracker.Actions.HasFlag(Actions.PutIntoRecordingMode);
                            break;
                        case AssertionTrackerShould.NotBeRecording:
                            shouldThrow = assertionTracker.Actions.HasFlag(Actions.PutIntoRecordingMode);
                            break;
                        case AssertionTrackerShould.BeMusted:
                            shouldThrow = !assertionTracker.Actions.HasFlag(Actions.Musted);
                            break;
                        case AssertionTrackerShould.NotBeMusted:
                            shouldThrow = assertionTracker.Actions.HasFlag(Actions.Musted);
                            break;
                        case AssertionTrackerShould.BeEached:
                            shouldThrow = !assertionTracker.Actions.HasFlag(Actions.Eached);
                            break;
                        case AssertionTrackerShould.NotBeEached:
                            shouldThrow = assertionTracker.Actions.HasFlag(Actions.Eached);
                            break;
                        case AssertionTrackerShould.BeVerifiedAtLeastOnce:
                            shouldThrow = !assertionTracker.Actions.HasFlag(Actions.VerifiedAtLeastOnce);
                            break;
                        case AssertionTrackerShould.NotBeVerified:
                            shouldThrow = assertionTracker.Actions.HasFlag(Actions.VerifiedAtLeastOnce);
                            break;
                        case AssertionTrackerShould.HaveEachedValueVerifiedForIteration:
                            shouldThrow = !assertionTracker.Actions.HasFlag(Actions.EachedValueVerifiedForIteration);
                            break;
                        case AssertionTrackerShould.NotHaveEachedValueVerifiedForIteration:
                            shouldThrow = assertionTracker.Actions.HasFlag(Actions.EachedValueVerifiedForIteration);
                            break;
                        default:
                            shouldThrow = true;
                            break;
                    }

                    if (shouldThrow)
                    {
                        break;
                    }
                }
            }

            if (shouldThrow)
            {
                Verifications.ThrowImproperUseOfFramework(Verifications.SubjectAndOperationSequencingErrorMessage);
            }
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private static AssertionTracker As<TSubject>(
            [ValidatedNotNull] this TSubject value,
            string name,
            AssertionKind assertionKind)
        {
            if (value is AssertionTracker tracker)
            {
                tracker.ThrowImproperUseOfFrameworkIfDetected(AssertionTrackerShould.NotExist);
            }

            var result = value.BuildTrackerFromAnonymousObject(name, assertionKind) ?? new AssertionTracker
            {
                SubjectValue = value,
                SubjectName = name,
                SubjectType = typeof(TSubject),
                AssertionKind = assertionKind,
            };

            if (name != null)
            {
                result.Actions |= Actions.Named;
            }

            if (assertionKind != AssertionKind.Unknown)
            {
                result.Actions |= Actions.Categorized;
            }

            return result;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private static AssertionTracker BuildTrackerFromAnonymousObject<TSubject>(
            [ValidatedNotNull] this TSubject value,
            string name = null,
            AssertionKind assertionKind = AssertionKind.Unknown)
        {
            var subjectType = typeof(TSubject);

            AssertionTracker result = null;

            if (!ReferenceEquals(value, null))
            {
                if (subjectType.IsClosedAnonymousTypeFastCheck())
                {
                    // with one property?  that's the subject we are trying to apply verification to.
                    var properties = subjectType.GetProperties();
                    if (properties.Length == 1)
                    {
                        result = new AssertionTracker
                        {
                            SubjectValue = properties[0].GetValue(value, null),
                            SubjectName = name ?? properties[0].Name,
                            SubjectType = properties[0].PropertyType,
                            AssertionKind = assertionKind,
                        };

                        if (assertionKind != AssertionKind.Unknown)
                        {
                            result.Actions |= Actions.Categorized;
                        }

                        if (result.SubjectName != null)
                        {
                            result.Actions |= Actions.Named;
                        }
                    }
                    else
                    {
                        var errorMessage = string.Format(CultureInfo.InvariantCulture, Verifications.AnonymousObjectDoesNotHaveSinglePropertyErrorMessage, properties.Length, string.Join(", ", properties.Select(_ => _.Name).ToArray()));

                        Verifications.ThrowImproperUseOfFramework(errorMessage);
                    }
                }
            }

            return result;
        }
    }
}
